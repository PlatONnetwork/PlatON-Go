#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#   @Time    : 2020/1/2 10:41
#   @Author  : PlatON-Developer
#   @Site    : https://github.com/PlatONnetwork/
import os
import time
import pytest
from decimal import Decimal

from common.log import log
from common.key import mock_duplicate_sign
from tests.lib.genesis import to_genesis
from tests.lib.client import Client
from tests.lib.utils import assert_code, get_pledge_list, von_amount
from tests.ppos.conftest import create_staking, calculate


def calculate_switch_block(node, economic):
    block_number = node.block_number
    return int(block_number / economic.settlement_size) * economic.settlement_size


def calculate_reward(block_reward, staking_reward, block_num, reward):
    delegate_reward = int(Decimal(str(staking_reward))*Decimal(str(reward))/Decimal(str(10000)) + Decimal(str(int(Decimal(str(block_reward))*Decimal(str(reward))/Decimal(str(10000))))) * Decimal(str(block_num)))
    total_reward = int(Decimal(str(staking_reward)) + Decimal(str(block_reward)) * Decimal(str(block_num)))
    return total_reward, delegate_reward


def calculate_pool_balance(node, economic):
    return node.eth.getBalance(node.web3.delegateRewardAddress, calculate_switch_block(node, economic))


def get_ben_balance(node, economic, ben_address):
    return node.eth.getBalance(ben_address, calculate_switch_block(node, economic))


def assert_reward_total(candidate_info, *args):
    for value in args:
        assert candidate_info["Ret"]["DelegateRewardTotal"] == value


def assert_reward_per(candidate_info, reward):
    assert candidate_info["Ret"]["RewardPer"] == reward


def assert_next_reward_per(candidate_info, next_reward):
    assert candidate_info["Ret"]["NextRewardPer"] == next_reward


@pytest.mark.P0
def test_DG_TR_001(client_consensus, reset_environment):
    """
    Adjust the dividend ratio of the built-in nodes and verify the total commission rewards generated by the nodes
    :param client_consensus:
    :return:
    """
    reward = 1000
    economic = client_consensus.economic
    node = client_consensus.node
    candidate_info = client_consensus.ppos.getCandidateInfo(node.node_id)
    log.info("first candidate info:{}".format(candidate_info))
    assert_reward_per(candidate_info, 0)
    economic.wait_settlement_blocknum(node, 1)
    result = client_consensus.staking.edit_candidate(economic.cfg.DEVELOPER_FOUNDATAION_ADDRESS, economic.cfg.INCENTIVEPOOL_ADDRESS, reward_per=reward)
    assert_code(result, 0)
    candidate_info = client_consensus.ppos.getCandidateInfo(node.node_id)
    log.info("second candidate info:{}".format(candidate_info))
    assert_reward_per(candidate_info, 0)
    edit_after_balance = node.eth.getBalance(economic.cfg.INCENTIVEPOOL_ADDRESS)
    log.info("Get the balance before editing：{}".format(edit_after_balance))
    client_consensus.economic.wait_settlement_blocknum(node)
    candidate_info = client_consensus.ppos.getCandidateInfo(node.node_id)
    log.info("last candidate info:{}".format(candidate_info))
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))
    assert node.eth.getBalance(economic.cfg.INCENTIVEPOOL_ADDRESS) - edit_after_balance == 0


@pytest.mark.P0
def test_DG_TR_002(client_consensus, reset_environment):
    """
    Adjust the built-in node income address and dividend ratio, and verify the total commission rewards generated by the node
    :param client_consensus:
    :return:
    """
    reward = 1000
    economic = client_consensus.economic
    node = client_consensus.node
    candidate_info = client_consensus.ppos.getCandidateInfo(node.node_id)
    log.info("View built-in node information：{}".format(candidate_info))
    assert candidate_info["Ret"]["RewardPer"] == 0
    log.info("editing built in nodes")
    economic.wait_settlement_blocknum(node, 1)
    result = client_consensus.staking.edit_candidate(economic.cfg.DEVELOPER_FOUNDATAION_ADDRESS, economic.cfg.INCENTIVEPOOL_ADDRESS,
                                                     reward_per=reward)
    assert_code(result, 0)
    candidate_info = client_consensus.ppos.getCandidateInfo(node.node_id)
    log.info("Verify the modification")
    assert_reward_per(candidate_info, 0)
    assert candidate_info["Ret"]["BenefitAddress"] == economic.cfg.INCENTIVEPOOL_ADDRESS
    log.info("waiting for a settlement cycle")
    economic.wait_settlement_blocknum(node)
    candidate_info = client_consensus.ppos.getCandidateInfo(node.node_id)
    log.info("querying node information:{}".format(candidate_info))
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))


@pytest.mark.P1
def test_DG_TR_003(staking_node_client):
    """
    调整非内置节点分红比例，验证节点产生的总委托奖励
    :param staking_node_client:
    :return:
    """
    economic = staking_node_client.economic
    node = staking_node_client.node
    result = staking_node_client.delegate.delegate(0, staking_node_client.delegate_address)
    assert_code(result, 0)
    reward = 2000
    log.info("modify node dividend ratio")
    economic.wait_settlement_blocknum(node, 1)
    result = staking_node_client.staking.edit_candidate(staking_node_client.staking_address,
                                                        staking_node_client.staking_address, reward_per=reward)
    assert_code(result, 0)
    candidate_info = staking_node_client.ppos.getCandidateInfo(node.node_id)
    log.info("querying node information：{}".format(candidate_info))
    log.info("check dividend ratio")
    assert_reward_per(candidate_info, staking_node_client.reward)
    assert_next_reward_per(candidate_info, reward)
    log.info("waiting for a settlement cycle")
    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    log.info("query block reward and pledge reward：{}，{}".format(block_reward, staking_reward))
    economic.wait_settlement_blocknum(node)
    candidate_info = staking_node_client.ppos.getCandidateInfo(node.node_id)
    log.info("querying node information：{}".format(candidate_info))
    assert_reward_per(candidate_info, reward)
    delegate_reward = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    log.info("the total commission reward is:{}".format(delegate_reward))
    assert_reward_total(candidate_info, von_amount(delegate_reward, 3), calculate_pool_balance(node, economic))


@pytest.mark.P1
@pytest.mark.parametrize('value', [0, 499, 500])
def test_DG_TR_003_01(client_noconsensus, value):
    """
    增加非内置节点分红比例<rewardPerMaxChangeRange值
    :param staking_node_client:
    :return:
    """
    economic = client_noconsensus.economic
    node = client_noconsensus.node
    address, _ = economic.account.generate_account(node.web3, von_amount(economic.create_staking_limit, 2))
    result = client_noconsensus.staking.create_staking(0, address, address, reward_per=1000)
    print(result)
    assert_code(result, 0)
    delegate_address, _ = economic.account.generate_account(node.web3, economic.create_staking_limit)
    result = client_noconsensus.delegate.delegate(0, delegate_address)
    assert_code(result, 0)
    log.info("modify node dividend ratio")
    if value != 0:
        economic.wait_settlement_blocknum(node, 1)
    reward = 1000 + value
    result = client_noconsensus.staking.edit_candidate(address, address, reward_per=reward)
    assert_code(result, 0)
    candidate_info = client_noconsensus.ppos.getCandidateInfo(node.node_id)
    log.info("querying node information：{}".format(candidate_info))
    log.info("check dividend ratio")
    assert_reward_per(candidate_info, 1000)
    assert_next_reward_per(candidate_info, reward)
    log.info("waiting for a settlement cycle")
    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    log.info("query block reward and pledge reward：{}，{}".format(block_reward, staking_reward))
    economic.wait_settlement_blocknum(node)
    candidate_info = client_noconsensus.ppos.getCandidateInfo(node.node_id)
    log.info("querying node information：{}".format(candidate_info))
    assert_reward_per(candidate_info, reward)
    economic.env.deploy_all()


@pytest.mark.P1
@pytest.mark.parametrize('value', [0, 999, 1000])
def test_DG_TR_003_02(staking_node_client, value):
    """
    减少非内置节点分红比例<rewardPerMaxChangeRange值
    :param staking_node_client:
    :return:
    """
    economic = staking_node_client.economic
    node = staking_node_client.node
    result = staking_node_client.delegate.delegate(0, staking_node_client.delegate_address)
    assert_code(result, 0)
    log.info("modify node dividend ratio")
    economic.wait_settlement_blocknum(node, 1)
    result = node.ppos.getCandidateInfo(node.node_id)
    current_commission_ratio = result['Ret']['RewardPer']
    new_commission_ratio = current_commission_ratio - value
    result = staking_node_client.staking.edit_candidate(staking_node_client.staking_address,
                                                        staking_node_client.staking_address, reward_per=new_commission_ratio)
    assert_code(result, 0)
    candidate_info = staking_node_client.ppos.getCandidateInfo(node.node_id)
    log.info("querying node information：{}".format(candidate_info))
    log.info("check dividend ratio")
    assert_reward_per(candidate_info, staking_node_client.reward)
    assert_next_reward_per(candidate_info, new_commission_ratio)
    log.info("waiting for a settlement cycle")
    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    log.info("query block reward and pledge reward：{}，{}".format(block_reward, staking_reward))
    economic.wait_settlement_blocknum(node)
    candidate_info = staking_node_client.ppos.getCandidateInfo(node.node_id)
    log.info("querying node information：{}".format(candidate_info))
    assert_reward_per(candidate_info, new_commission_ratio)
    economic.env.deploy_all()


@pytest.mark.P1
def test_DG_TR_003_03(staking_node_client, reset_environment):
    """
    调整非内置节点分红比例>rewardPerMaxChangeRange值
    :param staking_node_client:
    :return:
    """
    economic = staking_node_client.economic
    node = staking_node_client.node
    result = staking_node_client.delegate.delegate(0, staking_node_client.delegate_address)
    assert_code(result, 0)
    addition_reward = 2000 + economic.genesis.economicModel.staking.rewardPerMaxChangeRange + 1
    log.info("modify node dividend ratio")
    economic.wait_settlement_blocknum(node, 1)
    result = staking_node_client.staking.edit_candidate(staking_node_client.staking_address,
                                                        staking_node_client.staking_address, reward_per=addition_reward)
    assert_code(result, 301009)

    reduce_reward = 2000 - (economic.genesis.economicModel.staking.rewardPerMaxChangeRange + 1)
    log.info("modify node dividend ratio")
    result = staking_node_client.staking.edit_candidate(staking_node_client.staking_address,
                                                        staking_node_client.staking_address, reward_per=reduce_reward)
    assert_code(result, 301009)


@pytest.mark.P1
def test_DG_TR_003_04(client_noconsensus, reset_environment):
    """
    调整非内置节点分红比例超过万分比
    :param staking_node_client:
    :return:
    """
    economic = client_noconsensus.economic
    node = client_noconsensus.node
    address, _ = economic.account.generate_account(node.web3, von_amount(economic.create_staking_limit, 2))
    result = client_noconsensus.staking.create_staking(0, address, address,reward_per=9600)
    assert_code(result, 0)
    economic.wait_settlement_blocknum(node, 1)
    addition_reward = 9600 + economic.genesis.economicModel.staking.rewardPerMaxChangeRange
    log.info("modify node dividend ratio")
    result = client_noconsensus.staking.edit_candidate(address, address, reward_per=addition_reward)
    assert_code(result, 301007)


@pytest.mark.P1
def DG_TR_003_05(client_noconsensus):
    """
    调整非内置节点分红比例负
    :param client_noconsensus:
    :return:
    """
    economic = client_noconsensus.economic
    node = client_noconsensus.node
    address, _ = economic.account.generate_account(node.web3, von_amount(economic.create_staking_limit, 2))
    result = client_noconsensus.staking.create_staking(0, address, address,reward_per=400)
    assert_code(result, 0)
    economic.wait_settlement_blocknum(node, 1)
    addition_reward = 400 - economic.genesis.economicModel.staking.rewardPerMaxChangeRange
    log.info("modify node dividend ratio")
    result = client_noconsensus.staking.edit_candidate(address, address, reward_per=addition_reward)
    # assert_code(result, 301007)
    log.info("nodeinfo: {}".format(client_noconsensus.ppos.getCandidateInfo(node.node_id)))


@pytest.mark.P1
def test_DG_TR_003_06(client_noconsensus):
    """
    调整非内置节点分红比例时限
    :param staking_node_client:
    :return:
    """
    economic = client_noconsensus.economic
    node = client_noconsensus.node
    address, _ = economic.account.generate_account(node.web3, von_amount(economic.create_staking_limit, 2))
    result = client_noconsensus.staking.create_staking(0, address, address, reward_per=1000)
    assert_code(result, 0)
    addition_reward = 1000 + economic.genesis.economicModel.staking.rewardPerMaxChangeRange
    log.info("modify node dividend ratio")
    result = client_noconsensus.staking.edit_candidate(address, address, reward_per=addition_reward)
    assert_code(result, 301008)
    economic.wait_settlement_blocknum(node, 1)
    result = client_noconsensus.staking.edit_candidate(address, address, reward_per=addition_reward)
    assert_code(result, 0)
    economic.wait_settlement_blocknum(node)
    candidate_info = client_noconsensus.ppos.getCandidateInfo(node.node_id)
    log.info("querying node information：{}".format(candidate_info))
    assert_reward_per(candidate_info, addition_reward)
    addition_reward = addition_reward + economic.genesis.economicModel.staking.rewardPerMaxChangeRange
    result = client_noconsensus.staking.edit_candidate(address, address, reward_per=addition_reward)
    assert_code(result, 301008)


@pytest.mark.P1
def test_DG_TR_004(staking_node_client):
    """
    When the node has no commission, verify the total commission reward generated by the node (hesitation period)
    :param staking_node_client:
    :return:
    """
    node = staking_node_client.node
    candidate_info = staking_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0)


@pytest.mark.P1
def test_DG_TR_005(global_test_env, reset_environment, staking_cfg):
    """
    When the node has no commission, verify the total commission reward (candidate) generated by the node
    :param global_test_env:
    :param reset_environment:
    :param staking_cfg:
    :return:
    """
    log.info("modify verification number")
    genesis_cfg = global_test_env.genesis_config
    genesis = to_genesis(genesis_cfg)
    genesis.economicModel.staking.maxValidators = 4
    genesis_file = os.path.join(global_test_env.cfg.env_tmp, "dg_tr_005_genesis.json")
    genesis.to_file(genesis_file)
    global_test_env.deploy_all(genesis_file)
    node = global_test_env.get_a_normal_node()
    client = Client(global_test_env, node, staking_cfg)
    log.info("pledge a node")
    create_staking(client, reward=1000)
    client.economic.wait_settlement_blocknum(node)
    candidate_info = client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0)


@pytest.mark.P0
def test_DG_TR_006(staking_node_client):
    """
    When the node has no delegation, the total delegation reward generated by the verification node (validator)
    :param staking_node_client:
    :return:
    """
    economic = staking_node_client.economic
    node = staking_node_client.node
    economic.wait_settlement_blocknum(node)
    start_balance = get_ben_balance(node, economic, staking_node_client.staking_address)
    log.info("starting amount:{}".format(start_balance))
    block_reward, staking_reward = economic.get_current_year_reward(node)
    log.info("query block reward and pledge reward：{}，{}".format(block_reward, staking_reward))
    economic.wait_settlement_blocknum(node)
    end_balance = get_ben_balance(node, economic, staking_node_client.staking_address)
    log.info("end balance:{}".format(end_balance))
    block_num = economic.get_number_blocks_in_interval(node)
    log.info("This node generates blocks in this settlement cycle:{}".format(block_num))
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, reward=0)
    assert total_reward == end_balance - start_balance


@pytest.mark.P2
def test_DG_TR_007(delegate_node_client):
    """
    When the node has a commission, verify the total commission reward generated by the node (hesitation period)
    :param delegate_node_client:
    :return:
    """
    node = delegate_node_client.node
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0)
    delegate_info = node.ppos.getDelegateInfo(candidate_info["Ret"]["StakingBlockNum"], delegate_node_client.delegate_address, node.node_id)
    assert delegate_info["Ret"]["CumulativeIncome"] == 0


@pytest.mark.P2
def test_DG_TR_008(global_test_env, reset_environment, staking_cfg):
    """
    When a node has a commission, verify the total commission reward (candidate) generated by the node
    :param global_test_env:
    :param reset_environment:
    :param staking_cfg:
    :return:
    """
    log.info("modify verification number")
    genesis_cfg = global_test_env.genesis_config
    genesis = to_genesis(genesis_cfg)
    genesis.economicModel.staking.maxValidators = 4
    genesis_file = os.path.join(global_test_env.cfg.env_tmp, "dg_tr_005_genesis.json")
    genesis.to_file(genesis_file)
    global_test_env.deploy_all(genesis_file)
    node = global_test_env.get_a_normal_node()
    client = Client(global_test_env, node, staking_cfg)
    log.info("pledge a node")
    staking_address, delegate_address = create_staking(client, reward=1000)
    result = client.delegate.delegate(0, delegate_address)
    assert_code(result, 0)
    client.economic.wait_settlement_blocknum(node)
    candidate_info = client.ppos.getCandidateInfo(node.node_id)
    log.info("candidate info:{}".format(candidate_info))
    assert_reward_total(candidate_info, 0)
    delegate_info = node.ppos.getDelegateInfo(candidate_info["Ret"]["StakingBlockNum"], delegate_address, node.node_id)
    log.info("delegate info:{}".format(delegate_info))
    assert delegate_info["Ret"]["CumulativeIncome"] == 0


@pytest.mark.P0
def test_DG_TR_009(delegate_node_client):
    """
    When the node has a commission, the total commission reward (validator) generated by the verification node
    :param delegate_node_client:
    :return:
    """
    node = delegate_node_client.node
    economic = delegate_node_client.economic

    economic.wait_settlement_blocknum(node)
    start_balance = get_ben_balance(node, economic, delegate_node_client.staking_address)
    log.info("Pledged balance at the end of the first settlement cycle：{}".format(start_balance))
    block_reward, staking_reward = economic.get_current_year_reward(node)
    log.info("in the second settlement cycle staking reward:{} block reward:{}".format(staking_reward, block_reward))

    economic.wait_settlement_blocknum(node)
    end_balance = get_ben_balance(node, economic, delegate_node_client.staking_address)
    log.info("Pledged balance at the end of the second settlement cycle：{}".format(end_balance))
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, delegate_node_client.reward)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    log.info("candidate info:{}".format(candidate_info))
    assert_reward_total(candidate_info, delegate_reward, calculate_pool_balance(node, economic))
    assert_reward_per(candidate_info, delegate_node_client.reward)
    assert end_balance - start_balance == total_reward - delegate_reward


@pytest.mark.P0
def test_DG_TR_010(client_new_node, reset_environment):
    """
    Verify that the dividend payout ratio of the node is set to 0 ‱, verify the dividend payout pool and node revenue
    :param client_new_node:
    :param reset_environment:
    :return:
    """
    reward = 0
    node = client_new_node.node
    economic = client_new_node.economic
    staking_address, delegate_address = create_staking(client_new_node, reward)
    result = client_new_node.delegate.delegate(0, delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(staking_address, switch_block)
    log.info("Pledged balance at the end of the first settlement cycle：{}".format(start_balance))
    block_reward, staking_reward = economic.get_current_year_reward(node)
    log.info("in the second settlement cycle staking reward:{} block reward:{}".format(staking_reward, block_reward))

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    switch_block = calculate_switch_block(node, economic)
    end_balance = node.eth.getBalance(staking_address, switch_block)
    log.info("Pledged balance at the end of the second settlement cycle：{}".format(end_balance))
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    log.info("candidate info:{}".format(candidate_info))
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, reward)
    assert end_balance - start_balance == total_reward


def create_staking_dif_ben(client, reward):
    amount = calculate(client.economic.create_staking_limit, 5)
    staking_amount = calculate(client.economic.create_staking_limit, 2)
    staking_address, _ = client.economic.account.generate_account(client.node.web3, amount)
    ben_address, _ = client.economic.account.generate_account(client.node.web3, 0)
    delegate_address, _ = client.economic.account.generate_account(client.node.web3, client.economic.add_staking_limit * 5)
    result = client.staking.create_staking(0, ben_address, staking_address, amount=staking_amount, reward_per=reward)
    assert_code(result, 0)
    return staking_address, delegate_address, ben_address


@pytest.mark.P2
def test_DG_TR_011(client_new_node, reset_environment):
    """
    Adjust the dividend ratio after commissioning to verify the dividend pool and node income
    :param client_new_node:
    :return:
    """
    reward = 1000
    node = client_new_node.node
    economic = client_new_node.economic
    staking_address, delegate_address, ben_address = create_staking_dif_ben(client_new_node, 0)

    economic.wait_settlement_blocknum(node)
    result = client_new_node.delegate.delegate(0, delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(ben_address, switch_block)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0)
    result = client_new_node.staking.edit_candidate(staking_address, ben_address, reward_per=reward)
    assert_code(result, 0)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_next_reward_per(candidate_info, reward)

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, reward)
    end_balance = node.eth.getBalance(ben_address, switch_block + economic.settlement_size)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))
    assert_reward_per(candidate_info, reward)
    assert end_balance - start_balance >= total_reward
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, reward)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)

    assert_reward_total(candidate_info, delegate_reward, calculate_pool_balance(node, economic))
    end_balance_two = node.eth.getBalance(ben_address, switch_block + economic.settlement_size + economic.settlement_size)
    assert end_balance_two - end_balance == total_reward - delegate_reward


@pytest.mark.P2
def test_DG_TR_012(client_new_node, reset_environment):
    """
    Adjust the dividend ratio after redeeming part of the commission, verify the dividend pool and node income
    :param client_new_node:
    :return:
    """
    reward = 1000
    update_reward = 2000
    node = client_new_node.node
    economic = client_new_node.economic
    staking_address, delegate_address, ben_address = create_staking_dif_ben(client_new_node, reward)

    economic.wait_settlement_blocknum(node)
    result = client_new_node.delegate.delegate(0, delegate_address, amount=economic.delegate_limit * 2)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(ben_address, switch_block)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))
    result = client_new_node.staking.edit_candidate(staking_address, ben_address, reward_per=update_reward)
    assert_code(result, 0)
    result = client_new_node.delegate.withdrew_delegate(candidate_info["Ret"]["StakingBlockNum"], delegate_address)
    assert_code(result, 0)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_next_reward_per(candidate_info, update_reward)

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, reward)
    end_balance = node.eth.getBalance(ben_address, switch_block + economic.settlement_size)
    assert end_balance - start_balance >= total_reward - delegate_reward
    block_reward, staking_reward = economic.get_current_year_reward(node)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, delegate_reward, calculate_pool_balance(node, economic))
    assert node.eth.getBalance(node.web3.delegateRewardAddress, calculate_switch_block(node, economic)) == delegate_reward

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward_two = calculate_reward(block_reward, staking_reward, block_num, update_reward)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, delegate_reward + delegate_reward_two, calculate_pool_balance(node, economic))

    end_balance_two = node.eth.getBalance(ben_address, switch_block + economic.settlement_size + economic.settlement_size)
    assert end_balance_two - end_balance == total_reward - delegate_reward_two


@pytest.mark.P2
def test_DG_TR_013(client_new_node, reset_environment):
    """
    Adjust the dividend ratio after redeeming all commissions to verify the dividend pool and node income
    :param client_new_node:
    :return:
    """
    reward = 1000
    update_reward = 2000
    node = client_new_node.node
    economic = client_new_node.economic
    staking_address, delegate_address, ben_address = create_staking_dif_ben(client_new_node, reward)

    economic.wait_settlement_blocknum(node)
    result = client_new_node.delegate.delegate(0, delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(ben_address, switch_block)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    result = client_new_node.staking.edit_candidate(staking_address, ben_address, reward_per=update_reward)
    assert_code(result, 0)
    result = client_new_node.delegate.withdrew_delegate(candidate_info["Ret"]["StakingBlockNum"], delegate_address)
    assert_code(result, 0)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_next_reward_per(candidate_info, update_reward)

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, 0)
    end_balance = node.eth.getBalance(ben_address, switch_block + economic.settlement_size)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))
    assert end_balance - start_balance >= total_reward
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    assert node.eth.getBalance(node.web3.delegateRewardAddress, switch_block) == 0
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))
    end_balance_two = node.eth.getBalance(ben_address, switch_block)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, update_reward)
    assert end_balance_two - end_balance == total_reward


@pytest.mark.P2
def test_DG_TR_013_2(client_new_node, reset_environment):
    """
    Adjust the dividend ratio after redeeming all commissions to verify the dividend pool and node income
    :param client_new_node:
    :return:
    """
    reward = 1000
    update_reward = 2000
    node = client_new_node.node
    economic = client_new_node.economic
    staking_address, delegate_address, ben_address = create_staking_dif_ben(client_new_node, reward)
    result = client_new_node.delegate.delegate(0, delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward_one = calculate_reward(block_reward, staking_reward, block_num, reward)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, calculate_pool_balance(node, economic), delegate_reward_one)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(ben_address, switch_block)
    result = client_new_node.delegate.withdrew_delegate(candidate_info["Ret"]["StakingBlockNum"], delegate_address)
    assert_code(result, 0)
    result = client_new_node.staking.edit_candidate(staking_address, ben_address, reward_per=update_reward)
    assert_code(result, 0)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_next_reward_per(candidate_info, update_reward)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    # balance_pool = int(Decimal(str(calculate_pool_balance(node, economic))) % Decimal(str(10**10)))

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward_two = calculate_reward(block_reward, staking_reward, block_num, reward)
    end_balance = node.eth.getBalance(ben_address, switch_block)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_per(candidate_info, update_reward)
    assert_reward_total(candidate_info, delegate_reward_one)
    assert calculate_pool_balance(node, economic) == 0
    assert end_balance - start_balance >= total_reward


@pytest.mark.P2
def test_DG_TR_014(client_new_node, reset_environment):
    """
    Adjust the dividend ratio after receiving dividends to verify the dividend pool and node income
    :param client_new_node:
    :return:
    """
    reward = 1000
    update_reward = 2000
    node = client_new_node.node
    economic = client_new_node.economic
    staking_address, delegate_address, ben_address = create_staking_dif_ben(client_new_node, reward)
    result = client_new_node.delegate.delegate(0, delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward_one = calculate_reward(block_reward, staking_reward, block_num, reward)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, calculate_pool_balance(node, economic), delegate_reward_one)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(ben_address, switch_block)
    result = client_new_node.delegate.withdraw_delegate_reward(delegate_address)
    assert_code(result, 0)
    result = client_new_node.staking.edit_candidate(staking_address, ben_address, reward_per=update_reward)
    assert_code(result, 0)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_next_reward_per(candidate_info, update_reward)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    # balance_pool = int(Decimal(str(calculate_pool_balance(node, economic))) % Decimal(str(10**10)))
    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward_two = calculate_reward(block_reward, staking_reward, block_num, reward)
    end_balance = node.eth.getBalance(ben_address, switch_block)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    total_delegate_reward = delegate_reward_two + delegate_reward_one
    assert_reward_total(candidate_info, total_delegate_reward)
    assert calculate_pool_balance(node, economic) == delegate_reward_two
    assert end_balance - start_balance >= total_reward - delegate_reward_two
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    total_reward, delegate_reward_thr = calculate_reward(block_reward, staking_reward, block_num, update_reward)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, delegate_reward_one + delegate_reward_two + delegate_reward_thr)
    assert calculate_pool_balance(node, economic) == delegate_reward_two + delegate_reward_thr
    end_balance_two = node.eth.getBalance(ben_address, switch_block)
    assert end_balance_two - end_balance == total_reward - delegate_reward_thr


@pytest.mark.P0
def test_DG_TR_015(client_new_node, reset_environment):
    """
    Verify that the dividend payout ratio of the node is set to 10000 ‱, verify the dividend payout pool and node revenue
    :param client_new_node:
    :param reset_environment:
    :return:
    """
    reward = 10000
    node = client_new_node.node
    economic = client_new_node.economic
    staking_address, delegate_address = create_staking(client_new_node, reward)
    result = client_new_node.delegate.delegate(0, delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(staking_address, switch_block)
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_per(candidate_info, reward)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, reward)
    delegate_info = node.ppos.getDelegateInfo(candidate_info["Ret"]["StakingBlockNum"], delegate_address, node.node_id)
    assert delegate_info["Ret"]["CumulativeIncome"] == 0
    assert_reward_total(candidate_info, delegate_reward, total_reward, calculate_pool_balance(node, economic))
    end_balance = node.eth.getBalance(staking_address, switch_block)
    assert end_balance - start_balance == 0


@pytest.mark.P0
def test_DG_TR_016(client_new_node, reset_environment):
    """
    Verify the adjustment of the dividend ratio of the nodes, verify the dividend pool and node revenue
    :param client_new_node:
    :return:
    """
    delegate_node_client = client_new_node
    reward = 1000
    update_reward = 2000
    node = delegate_node_client.node
    economic = delegate_node_client.economic
    staking_address, delegate_address, ben_address = create_staking_dif_ben(delegate_node_client, reward=reward)
    result = delegate_node_client.delegate.delegate(0, delegate_address)
    assert_code(result, 0)
    economic.wait_settlement_blocknum(node, 1)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(ben_address, switch_block)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    result = delegate_node_client.staking.edit_candidate(staking_address, ben_address, reward_per=update_reward)
    assert_code(result, 0)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_per(candidate_info, reward)
    assert_next_reward_per(candidate_info, update_reward)

    economic.wait_settlement_blocknum(node)

    block_num = economic.get_number_blocks_in_interval(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    total_reward_one, delegate_reward_one = calculate_reward(block_reward, staking_reward, block_num, reward)
    assert_reward_total(candidate_info, von_amount(delegate_reward_one, 2), calculate_pool_balance(node, economic))
    assert_reward_per(candidate_info, update_reward)
    switch_block = calculate_switch_block(node, economic)
    end_balance_one = node.eth.getBalance(ben_address, switch_block)
    assert end_balance_one - start_balance >= total_reward_one - delegate_reward_one
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    time.sleep(5)
    switch_block = calculate_switch_block(node, economic)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert candidate_info["Ret"]["RewardPer"] == update_reward
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward_two, delegate_reward_two = calculate_reward(block_reward, staking_reward, block_num, update_reward)
    assert_reward_total(candidate_info, von_amount(delegate_reward_one, 2) + delegate_reward_two, calculate_pool_balance(node, economic))
    end_balance_two = node.eth.getBalance(ben_address, switch_block)
    assert end_balance_two - end_balance_one == total_reward_two - delegate_reward_two


@pytest.mark.P2
def test_DG_TR_017(delegate_node_client):
    """
    When the verification node has a commission, exit and re-pledge
    :param delegate_node_client:
    :return:
    """
    reward = 2000
    node = delegate_node_client.node
    economic = delegate_node_client.economic

    economic.wait_settlement_blocknum(node)
    delegate_node_client.staking.withdrew_staking(delegate_node_client.staking_address)

    economic.wait_settlement_blocknum(node, number=2)
    staking_address, delegate_address = create_staking(delegate_node_client, reward)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_per(candidate_info, reward)
    assert_next_reward_per(candidate_info, reward)
    result = delegate_node_client.delegate.delegate(0, delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    delegate_reward = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    assert_reward_total(candidate_info, delegate_reward)


@pytest.mark.P2
def test_DG_TR_018(delegate_node_client):
    """
    After the entrusted node is punished by double signing, verify the total entrusted reward generated by the current node
    :param delegate_node_client:
    :return:
    """
    node = delegate_node_client.node
    economic = delegate_node_client.economic

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(delegate_node_client.staking_address, switch_block)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    report_address, _ = economic.account.generate_account(node.web3, node.web3.toWei(1, "ether"))
    for i in range(economic.consensus_wheel):
        verfiers = get_pledge_list(node.ppos.getValidatorList)
        if node.node_id in verfiers:
            break
        economic.wait_consensus_blocknum(node)
    else:
        assert False, "node cannot enter consensus round"
    data = mock_duplicate_sign(1, node.nodekey, node.blsprikey, node.block_number)
    result = delegate_node_client.duplicatesign.reportDuplicateSign(1, data, report_address)
    assert_code(result, 0)
    result = get_pledge_list(node.ppos.getVerifierList)
    assert node.node_id not in result

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))
    block_num = economic.get_number_blocks_in_interval(node)
    end_balance = node.eth.getBalance(delegate_node_client.staking_address, switch_block)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, 0)
    assert end_balance - start_balance == total_reward - staking_reward


@pytest.mark.P2
def test_DG_TR_018_2(delegate_node_client, reset_environment):
    """
    After the entrusted node is punished by double signing, verify the total entrusted reward generated by the current node
    :param delegate_node_client:
    :return:
    """
    node = delegate_node_client.node
    economic = delegate_node_client.economic

    economic.wait_settlement_blocknum(node)
    start_balance = get_ben_balance(node, economic, delegate_node_client.staking_address)
    block_reward_1, staking_reward_1 = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    block_reward_2, staking_reward_2 = economic.get_current_year_reward(node)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward_one, delegate_reward_one = calculate_reward(block_reward_1, staking_reward_1, block_num, delegate_node_client.reward)
    delegate_reward_one = economic.calculate_delegate_reward(node, block_reward_1, staking_reward_1, delegate_node_client.reward)
    report_address, _ = economic.account.generate_account(node.web3, node.web3.toWei(1, "ether"))

    for i in range(economic.consensus_wheel):
        verfiers = get_pledge_list(node.ppos.getValidatorList)
        if node.node_id in verfiers:
            break
        economic.wait_consensus_blocknum(node)
    else:
        assert False, "node cannot enter consensus round"
    data = mock_duplicate_sign(1, node.nodekey, node.blsprikey, node.block_number)
    result = delegate_node_client.duplicatesign.reportDuplicateSign(1, data, report_address)
    assert_code(result, 0)
    result = get_pledge_list(node.ppos.getVerifierList)
    assert node.node_id not in result

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, delegate_reward_one, calculate_pool_balance(node, economic))
    block_num_2 = economic.get_number_blocks_in_interval(node)
    end_balance = node.eth.getBalance(delegate_node_client.staking_address, switch_block)
    total_reward_2, delegate_reward_2 = calculate_reward(block_reward_2, staking_reward_2, block_num_2, 0)
    total = total_reward_one + total_reward_2 - delegate_reward_one - staking_reward_2
    assert end_balance - start_balance == total


@pytest.mark.P2
def test_DG_TR_019(client_new_node, reset_environment):
    """
    After the commissioning node exits, verify the total commissioning rewards generated by the current node
    :param client_new_node:
    :return:
    """
    reward = 1000
    node = client_new_node.node
    economic = client_new_node.economic
    staking_address, delegate_address, ben_address = create_staking_dif_ben(client_new_node, reward)
    result = client_new_node.delegate.delegate(0, delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    switch_block = calculate_switch_block(node, economic)
    start_balance = node.eth.getBalance(ben_address, switch_block)
    client_new_node.staking.withdrew_staking(staking_address)
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    end_balance = node.eth.getBalance(ben_address, switch_block + economic.settlement_size)
    block_num = economic.get_number_blocks_in_interval(node)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, reward)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, delegate_reward, calculate_pool_balance(node, economic))
    assert end_balance - start_balance == total_reward - delegate_reward


@pytest.mark.P1
def test_DG_TR_020(delegate_node_client):
    """
    Redeem part of the commission and verify the total commission rewards generated by the current node
    :param delegate_node_client:
    :return:
    """
    node = delegate_node_client.node
    economic = delegate_node_client.economic

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    delegate_node_client.delegate.withdrew_delegate(candidate_info["Ret"]["StakingBlockNum"],
                                                    delegate_node_client.delegate_address, amount=delegate_node_client.economic.add_staking_limit)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))

    economic.wait_settlement_blocknum(node)
    block_num = economic.get_number_blocks_in_interval(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, delegate_node_client.reward)
    assert_reward_total(candidate_info, delegate_reward, calculate_pool_balance(node, economic))


@pytest.mark.P1
def test_DG_TR_021(delegate_node_client):
    """
    Redeem all commissions and verify the total commission rewards generated by the current node
    :param delegate_node_client:
    :return:
    """
    node = delegate_node_client.node
    economic = delegate_node_client.economic

    economic.wait_settlement_blocknum(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    delegate_node_client.delegate.withdrew_delegate(candidate_info["Ret"]["StakingBlockNum"],
                                                    delegate_node_client.delegate_address,
                                                    amount=delegate_node_client.economic.add_staking_limit * 2)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))

    economic.wait_settlement_blocknum(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))


@pytest.mark.P1
def test_DG_TR_022(delegate_node_client):
    """
    Nodes have been commissioned multiple times to verify the total commission rewards generated by the current node (same settlement period)
    :param delegate_node_client:
    :return:
    """
    node = delegate_node_client.node
    economic = delegate_node_client.economic
    result = delegate_node_client.delegate.delegate(0, delegate_node_client.delegate_address)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    delegate_reward = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    assert_reward_total(candidate_info, delegate_reward, calculate_pool_balance(node, economic))


@pytest.mark.P1
def test_DG_TR_023(delegate_node_client):
    """
    Nodes have been commissioned multiple times to verify the total commission rewards generated by the current node (across settlement periods)
    :param delegate_node_client:
    :return:
    """
    node = delegate_node_client.node
    economic = delegate_node_client.economic

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    result = delegate_node_client.delegate.delegate(0, delegate_node_client.delegate_address)
    assert_code(result, 0)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, 0, calculate_pool_balance(node, economic))

    economic.wait_settlement_blocknum(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    reward_total_one = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    assert_reward_total(candidate_info, reward_total_one, calculate_pool_balance(node, economic))
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    candidate_info = delegate_node_client.ppos.getCandidateInfo(node.node_id)
    reward_total_two = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    assert_reward_total(candidate_info, reward_total_one + reward_total_two, calculate_pool_balance(node, economic))


@pytest.mark.P2
def test_DG_TR_024(client_new_node, reset_environment):
    """
    Nodes are commissioned by multiple accounts to verify the total commission rewards generated by the current node (same settlement period)
    :return:
    """
    reward = 1000
    node = client_new_node.node
    economic = client_new_node.economic
    create_staking(client_new_node, reward)
    delegate_address_1, _ = economic.account.generate_account(node.web3, economic.delegate_limit * 4)
    delegate_address_2, _ = economic.account.generate_account(node.web3, economic.delegate_limit * 4)
    result = client_new_node.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)
    result = client_new_node.delegate.delegate(0, delegate_address_2)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    reward_total = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    assert_reward_total(candidate_info, reward_total, calculate_pool_balance(node, economic))


@pytest.mark.P2
def test_DG_TR_025(client_new_node, reset_environment):
    """
    Nodes are commissioned by multiple accounts to verify the total commission rewards generated by the current node (across settlement periods)
    :return:
    """
    reward = 1000
    node = client_new_node.node
    economic = client_new_node.economic
    create_staking(client_new_node, reward)
    delegate_address_1, _ = economic.account.generate_account(node.web3, economic.delegate_limit * 4)
    delegate_address_2, _ = economic.account.generate_account(node.web3, economic.delegate_limit * 4)
    result = client_new_node.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)
    result = client_new_node.delegate.delegate(0, delegate_address_2)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    block_reward, staking_reward = economic.get_current_year_reward(node)
    result = client_new_node.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)
    result = client_new_node.delegate.delegate(0, delegate_address_2)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    reward_total_one = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    assert_reward_total(candidate_info, reward_total_one, calculate_pool_balance(node, economic))
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    candidate_info = client_new_node.ppos.getCandidateInfo(node.node_id)
    reward_total_two = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    assert_reward_total(candidate_info, reward_total_one + reward_total_two, calculate_pool_balance(node, economic))


@pytest.mark.P2
def test_DG_TR_026(clients_noconsensus, reset_environment):
    """
    Entrust multiple verification nodes to verify the total entrusted rewards generated by the current node (same settlement period)
    :return:
    """
    client_1 = clients_noconsensus[0]
    client_2 = clients_noconsensus[1]
    reward_1 = 1000
    reward_2 = 2000
    node_1 = client_1.node
    node_2 = client_2.node
    economic_1 = client_1.economic
    economic_2 = client_2.economic
    create_staking(client_1, reward_1)
    time.sleep(2)
    create_staking(client_2, reward_2)
    delegate_address_1, _ = economic_1.account.generate_account(node_1.web3, economic_1.delegate_limit * 4)
    result = client_1.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_1, node_id=node_2.node_id)
    assert_code(result, 0)

    economic_1.wait_settlement_blocknum(node_1)
    block_reward, staking_reward = economic_1.get_current_year_reward(node_1)

    economic_1.wait_settlement_blocknum(node_1)
    candidate_info_1 = client_1.ppos.getCandidateInfo(node_1.node_id)
    reward_total_1 = economic_1.calculate_delegate_reward(node_1, block_reward, staking_reward)
    assert_reward_total(candidate_info_1, reward_total_1)
    reward_total_2 = economic_2.calculate_delegate_reward(node_2, block_reward, staking_reward)
    candidate_info_2 = client_2.ppos.getCandidateInfo(node_2.node_id)
    assert_reward_total(candidate_info_2, reward_total_2)
    assert calculate_pool_balance(node_1, economic_1) == reward_total_1 + reward_total_2


@pytest.mark.P2
def test_DG_TR_027(clients_noconsensus, reset_environment):
    """
    Delegate multiple verification nodes to verify the total entrusted rewards generated by the current node (cross settlement period)
    :return:
    """
    client_1 = clients_noconsensus[0]
    client_2 = clients_noconsensus[1]
    reward_1 = 1000
    reward_2 = 2000
    node_1 = client_1.node
    node_2 = client_2.node
    economic_1 = client_1.economic
    economic_2 = client_2.economic
    create_staking(client_1, reward_1)
    time.sleep(2)
    create_staking(client_2, reward_2)
    delegate_address_1, _ = economic_1.account.generate_account(node_1.web3, economic_1.delegate_limit * 6)
    result = client_1.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_1, node_id=node_2.node_id)
    assert_code(result, 0)

    economic_1.wait_settlement_blocknum(node_1)
    block_reward, staking_reward = economic_1.get_current_year_reward(node_1)
    result = client_1.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_1, node_id=node_2.node_id)
    assert_code(result, 0)

    economic_1.wait_settlement_blocknum(node_1)
    candidate_info_1 = client_1.ppos.getCandidateInfo(node_1.node_id)
    reward_total_1_one = economic_1.calculate_delegate_reward(node_1, block_reward, staking_reward)
    assert candidate_info_1["Ret"]["DelegateRewardTotal"] == reward_total_1_one
    reward_total_2_one = economic_2.calculate_delegate_reward(node_2, block_reward, staking_reward)
    candidate_info_2 = client_2.ppos.getCandidateInfo(node_2.node_id)
    assert candidate_info_2["Ret"]["DelegateRewardTotal"] == reward_total_2_one
    block_reward, staking_reward = economic_1.get_current_year_reward(node_1)
    assert calculate_pool_balance(node_1, economic_1) == reward_total_1_one + reward_total_2_one

    economic_1.wait_settlement_blocknum(node_1)
    candidate_info_1 = client_1.ppos.getCandidateInfo(node_1.node_id)
    reward_total_1_two = economic_1.calculate_delegate_reward(node_1, block_reward, staking_reward)
    assert candidate_info_1["Ret"]["DelegateRewardTotal"] == reward_total_1_one + reward_total_1_two
    reward_total_2_two = economic_2.calculate_delegate_reward(node_2, block_reward, staking_reward)
    candidate_info_2 = client_2.ppos.getCandidateInfo(node_2.node_id)
    assert candidate_info_2["Ret"]["DelegateRewardTotal"] == reward_total_2_one + reward_total_2_two
    assert calculate_pool_balance(node_1, economic_1) == reward_total_1_one + reward_total_1_two + reward_total_2_one + reward_total_2_two


@pytest.mark.P2
def test_DG_TR_028(clients_noconsensus, reset_environment):
    """
    Multiple accounts commission multiple nodes to verify the total commission rewards generated by the current node (same settlement period)
    :return:
    """
    client_1 = clients_noconsensus[0]
    client_2 = clients_noconsensus[1]
    reward_1 = 1000
    reward_2 = 2000
    node_1 = client_1.node
    node_2 = client_2.node
    economic_1 = client_1.economic
    economic_2 = client_2.economic
    create_staking(client_1, reward_1)
    time.sleep(2)
    create_staking(client_2, reward_2)
    delegate_address_1, _ = economic_1.account.generate_account(node_1.web3, economic_1.delegate_limit * 4)
    delegate_address_2, _ = economic_1.account.generate_account(node_1.web3, economic_1.delegate_limit * 4)
    result = client_1.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_1, node_id=node_2.node_id)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_2)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_2, node_id=node_2.node_id)
    assert_code(result, 0)

    economic_1.wait_settlement_blocknum(node_1)
    block_reward, staking_reward = economic_1.get_current_year_reward(node_1)

    economic_1.wait_settlement_blocknum(node_1)
    candidate_info_1 = client_1.ppos.getCandidateInfo(node_1.node_id)
    reward_total_1 = economic_1.calculate_delegate_reward(node_1, block_reward, staking_reward)
    assert candidate_info_1["Ret"]["DelegateRewardTotal"] == reward_total_1
    reward_total_2 = economic_2.calculate_delegate_reward(node_2, block_reward, staking_reward)
    candidate_info_2 = client_2.ppos.getCandidateInfo(node_2.node_id)
    assert candidate_info_2["Ret"]["DelegateRewardTotal"] == reward_total_2
    assert calculate_pool_balance(node_1, economic_1) == reward_total_1 + reward_total_2


@pytest.mark.P2
def test_DG_TR_029(clients_noconsensus, reset_environment):
    """
    Multiple accounts entrust multiple nodes to verify the total entrusted rewards generated by the current node (cross settlement period)
    :return:
    """
    client_1 = clients_noconsensus[0]
    client_2 = clients_noconsensus[1]
    reward_1 = 1000
    reward_2 = 2000
    node_1 = client_1.node
    node_2 = client_2.node
    economic_1 = client_1.economic
    economic_2 = client_2.economic
    create_staking(client_1, reward_1)
    time.sleep(2)
    create_staking(client_2, reward_2)
    delegate_address_1, _ = economic_1.account.generate_account(node_1.web3, economic_1.delegate_limit * 4)
    delegate_address_2, _ = economic_1.account.generate_account(node_1.web3, economic_1.delegate_limit * 4)
    result = client_1.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_1, node_id=node_2.node_id)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_2)
    assert_code(result, 0)
    result = client_1.delegate.delegate(0, delegate_address_2, node_id=node_2.node_id)
    assert_code(result, 0)

    economic_1.wait_settlement_blocknum(node_1)
    block_reward, staking_reward = economic_1.get_current_year_reward(node_1)

    economic_1.wait_settlement_blocknum(node_1)
    candidate_info_1 = client_1.ppos.getCandidateInfo(node_1.node_id)
    reward_total_1 = economic_1.calculate_delegate_reward(node_1, block_reward, staking_reward)
    assert candidate_info_1["Ret"]["DelegateRewardTotal"] == reward_total_1
    reward_total_2 = economic_2.calculate_delegate_reward(node_2, block_reward, staking_reward)
    candidate_info_2 = client_2.ppos.getCandidateInfo(node_2.node_id)
    assert candidate_info_2["Ret"]["DelegateRewardTotal"] == reward_total_2
    block_reward, staking_reward = economic_1.get_current_year_reward(node_1)
    economic_1.wait_settlement_blocknum(node_1)
    candidate_info_1 = client_1.ppos.getCandidateInfo(node_1.node_id)
    reward_total_1_2 = economic_1.calculate_delegate_reward(node_1, block_reward, staking_reward)
    assert candidate_info_1["Ret"]["DelegateRewardTotal"] == reward_total_1 + reward_total_1_2
    reward_total_2_2 = economic_2.calculate_delegate_reward(node_2, block_reward, staking_reward)
    candidate_info_2 = client_2.ppos.getCandidateInfo(node_2.node_id)
    assert candidate_info_2["Ret"]["DelegateRewardTotal"] == reward_total_2 + reward_total_2_2
    assert calculate_pool_balance(node_1, economic_1) == reward_total_1 + reward_total_1_2 + reward_total_2 + reward_total_2_2


@pytest.mark.P2
# @pytest.mark.skip("Test case process is random and needs to be executed multiple times manually")
def test_DG_TR_030(clients_noconsensus, reset_environment):
    """
    The current consensus round consensus node is not in the settlement cycle list, verifying the node's revenue
    :return:
    """
    client = clients_noconsensus[0]
    client_2 = clients_noconsensus[1]
    reward = 1000
    node = client.node
    economic = client.economic
    amount = calculate(client.economic.create_staking_limit, 5)
    staking_amount = calculate(client.economic.create_staking_limit, 1)
    staking_address, _ = client.economic.account.generate_account(node.web3, amount)
    delegate_address, _ = client.economic.account.generate_account(node.web3, economic.add_staking_limit * 5)
    ben_address, _ = client.economic.account.generate_account(node.web3, 0)
    result = client.staking.create_staking(0, ben_address, staking_address, amount=staking_amount, reward_per=reward)
    assert_code(result, 0)
    result = client.delegate.delegate(0, delegate_address)
    assert_code(result, 0)
    economic.wait_settlement_blocknum(node)
    start_balance = get_ben_balance(node, economic, ben_address)
    create_staking(client_2, reward)
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    verfiers = get_pledge_list(node.ppos.getValidatorList)
    if node.node_id not in verfiers:
        assert False, "Node 1 did not participate in the first consensus round"

    block_num = economic.get_number_blocks_in_interval(node)
    end_balance = get_ben_balance(node, economic, ben_address)
    total_reward, delegate_reward = calculate_reward(block_reward, staking_reward, block_num, reward)
    candidate_info = node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, delegate_reward)
    assert end_balance - start_balance == total_reward - delegate_reward
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    candidate_info = node.ppos.getCandidateInfo(node.node_id)
    assert_reward_total(candidate_info, delegate_reward)
    block_num = economic.get_number_blocks_in_interval(node)
    end_balance_two = get_ben_balance(node, economic, ben_address)
    assert end_balance_two - end_balance == calculate(block_reward, block_num)


@pytest.mark.P1
def test_DG_TR_031(client_new_node, reset_environment):
    """
    领取分红，查看质押节点信息委托总收益金额
    :param client_new_node:
    :param reset_environment:
    :return:
    """
    reward = 1000
    node = client_new_node.node
    economic = client_new_node.economic
    create_staking(client_new_node, reward)
    delegate_address_1, _ = economic.account.generate_account(node.web3, economic.delegate_limit * 4)
    result = client_new_node.delegate.delegate(0, delegate_address_1)
    assert_code(result, 0)

    economic.wait_settlement_blocknum(node)
    log.info("Current block height：{}".format(node.eth.blockNumber))
    block_reward, staking_reward = economic.get_current_year_reward(node)

    economic.wait_settlement_blocknum(node)
    log.info("Current block height：{}".format(node.eth.blockNumber))
    reward_total_one = economic.calculate_delegate_reward(node, block_reward, staking_reward)
    candidate_info_1 = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert candidate_info_1["Ret"]["DelegateRewardTotal"] == reward_total_one
    result = client_new_node.delegate.withdraw_delegate_reward(delegate_address_1)
    assert_code(result, 0)
    candidate_info_2 = client_new_node.ppos.getCandidateInfo(node.node_id)
    assert candidate_info_2["Ret"]["DelegateRewardTotal"] == candidate_info_1["Ret"]["DelegateRewardTotal"]
